<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" mouseDownOutside="{onMouseDownOutside()}" width="500" height="435"
           creationComplete="{onCreationComplete()}" keyDown="{onKeyDown(event)}" backgroundAlpha="0">
<mx:Glow id="glowEffect" color="#F83838" duration="350" strength="3" />
<mx:Canvas left="15" right="15" height="100%" backgroundColor="#31394B" cornerRadius="6" borderStyle="solid" borderColor="#e0e0e0" borderThickness="3" >
	<mx:VBox left="10" right="10" top="10" bottom="10">
		<mx:Label text="Question:" styleName="textFeildLabel"/>
		<mx:TextArea id="questionField" width="100%" height="60" />
		<mx:HBox width="100%" verticalAlign="middle">
			<mx:Label text="Answers:" styleName="textFeildLabel"/>
			<mx:Label id="warningText" visible="false" text="You Must Select a Correct Answer" color="#F83838" showEffect="{glowEffect}"/>
		</mx:HBox>
		<mx:List id="mcList" width="100%" height="100%" variableRowHeight="true" editable="true" dataProvider="{_answerList}" itemRenderer="MultipleChoiceItem" rendererIsEditor="true" itemFocusIn="{onListItemFocusIn(event)}"></mx:List>
		<mx:Canvas width="100%">
			<mx:Button label="Done" click="{onDonePressed()}" textAlign="center" right="0" bottom="0"/>
		</mx:Canvas>
	</mx:VBox>
	<mx:Script>
		<![CDATA[
		import materia.questionStorage.Question;
		import mx.events.ListEvent;
		import mx.collections.ArrayCollection;
		import mx.controls.Alert;
		import mx.managers.PopUpManager;
		import com.adobe.utils.StringUtil;
		public static const TOP:int = 0;
		public static const BOTTOM:int = 1;
		public static const LEFT:int = 2;
		public static const RIGHT:int = 3;
		public static const MIDDLE:int = 4;
		private static const DEFAULT_TEXT:String = "[Enter An Answer Here]";
		private static const MAX_ANSWERS:int = 10;
		[Bindable]
		private var _answerList:ArrayCollection;
		public var question:Question;
		private var _setContentsPending:Boolean;
		private var _closeFunction:Function;
		private var _orientationPending:Boolean = false;
		private var _orientationPendingArgs:Array;
		public function onCreationComplete():void
		{
			_answerList = new ArrayCollection();
			var timer:Timer = new Timer(5, 1);
			timer.addEventListener(TimerEvent.TIMER_COMPLETE, validateMe, false, 0, true);
			//timer.start();
			questionField.setFocus();
			questionField.setSelection(0, questionField.length);
			mcList.addEventListener(MultipleChoiceItem.EVENT_DELETED, onDeleteItem);
			mcList.addEventListener(MultipleChoiceItem.ITEM_CHECKED, onCheckBoxSelected);
			mcList.addEventListener(MultipleChoiceItem.EVENT_ADD_NEW, onAddItem);
			if (_setContentsPending)
			{
				setContents(question, _closeFunction);
				_setContentsPending = false;
			}
			if (_orientationPending);
			{
				var i:int;
				for (i = 0; i < _orientationPendingArgs.length; i++)
				{
					setArrowOrientation(_orientationPendingArgs[i]);
				}
			}
		}
		public function setContents(question:Question, closeFunction:Function):void
		{
			this.question = question;
			_closeFunction = closeFunction;
			if (questionField == null)
			{
				_setContentsPending = true;
				return;
			}
			if (question.questions[0].text != Creator.EMPTY)
			{
				questionField.text = question.questions[0].text;
			}
			for (var i:int = 0; i < question.answers.length; i++)
			{
				addAnswer(question.answers[i].text, this.question.answers[i].value, this.question.answers[i].options.feedback);
			}
			addAnswer();
			//Add another empty question if there is only one question. Add 2 if there are none
			if (question.answers.length < 1)
			{
				addAnswer();
				addAnswer();
				addAnswer();
			}
			validateMe();
		}
		private function validateMe(event:Event = null):void
		{
			////trace("QuestionAnswerDataGrid::validateMe");
			this.validateNow();
			_answerList.refresh();
		}
		public function addAnswer(text:String = "", percent:int = 0, feedback:String = ""):void
		{
			_answerList.addItem({rowIndex:_answerList.length, feedback:feedback,
				percent:percent, text:text });
		}
		public function clearAnswers():void
		{
			for (var i:int = 0; i < _answerList.length - 1; i++)
			{
				_answerList.removeItemAt(i);
				i--;
			}
		}
		public function deleteItem(deleteIndex:int = -1):void
		{
			////trace("QuestionAnswerDataGrid::deleteItem");
			var selectionIndex:int = mcList.selectedIndex - 1;
			var index:int = deleteIndex;
			var allowDelete:Boolean = false;
			if (index < 0)
			{
				index = 0;
			}
			if (index < _answerList.length - 1)
			{
				allowDelete = true;
			}
			if (allowDelete)
			{
				var obj:Object = _answerList.getItemAt(index);
				_answerList.removeItemAt(index);
				updateItemIndexes(index);
				mcList.selectedIndex = selectionIndex;
				//only consider data changed if there was content in deleted item
//					if(wasEmpty == false)
//					{
//						dispatchEvent(new Event(FlexEvent.DATA_CHANGE));
//					}
//
//					dispatchEvent(new Event(DELETE_EVENT));
//					dispatchEvent(new DataGridEvent(DataGridEvent.ITEM_EDIT_END));
				updateItemIndexes(deleteIndex);
			}
		}
		public function updateItemIndexes(startIndex:int = 0):void
		{
			////trace("QuestionAnswerDataGrid::updateItemIndexes");
			for (var i:int = startIndex; i < _answerList.length; i++)
			{
				var item:* = _answerList.getItemAt(i);
				_answerList.getItemAt(i).rowIndex = i;
			}
			_answerList.refresh();
		}
		public function terminate():void
		{
			PopUpManager.removePopUp(this);
		}
		public function resetWarning():void
		{
			warningText.visible = false;
		}
		public function setArrowOrientation(a:int):void
		{
			if (leftArrow == null)
			{
				_orientationPending = true;
				if (_orientationPendingArgs == null)
				{
					_orientationPendingArgs = new Array();
				}
				_orientationPendingArgs.push(a);
				return;
			}
			else
			{
				_orientationPending = false;
			}
			switch (a)
			{
				case -1:
					break;
				case TOP:
					setArrowTop(80);
					break;
				case MIDDLE:
					setArrowMiddle(35);
					break;
				case BOTTOM:
					setArrowBottom(20);
					break;
				case LEFT:
					leftArrow.visible = true;
					rightArrow.visible = false;
					break;
				case RIGHT:
					leftArrow.visible = false;
					rightArrow.visible = true;
					break;
			}
		}
		private function setArrowTop(pos:int):void
		{
			leftArrow.setStyle("bottom", null);
			rightArrow.setStyle("bottom", null);
			leftArrow.setStyle("top", pos);
			rightArrow.setStyle("top", pos);
		}
		private function setArrowMiddle(pos:int):void
		{
			leftArrow.setStyle("verticalCenter", pos);
			rightArrow.setStyle("verticalCenter", pos);
		}
		private function setArrowBottom(pos:int):void
		{
			leftArrow.setStyle("top", null);
			rightArrow.setStyle("top", null);
			leftArrow.setStyle("bottom", pos);
			rightArrow.setStyle("bottom", pos);
		}
		public function onCheckBoxSelected(e:Event):void
		{
			e.stopPropagation();
			resetWarning();
		}
		public function onDonePressed(overrideChecks:Boolean = false):void
		{
			//Don't allow close until list is populated
			if (_answerList == null)
			{
				return;
			}
			var i:int; //for loops

			//Find if any answer is marked as correct
			var exists:Boolean = false;
			for (i = 0; i < _answerList.length; i++)
			{
				if (_answerList[i].percent == 100)
				{
					exists = true;
				}
			}
			//If no 100% answer is found, show warning text
			if (overrideChecks == false && exists == false)
			{
				if (warningText.visible == false)
				{
					warningText.visible = true;
				}
				return;
			}

			// update all the answers
			for (i = 0; i < _answerList.length - 1; i++)
			{
				if (StringUtil.trim(_answerList[i].text) == '')
				{
					trace('answer empty ' + i )
					_answerList.removeItemAt(i);
					i--;
				}
			}

			// update all the answers
			var len:int = _answerList.length - 1;
			for (i = 0; i < len; i++)
			{
				// need to add a new answer
				if (i >= this.question.answers.length) this.question.answers.push(new Object());

				this.question.answers[i].text = _answerList[i].text;
				this.question.answers[i].value = _answerList[i].percent;
				if (this.question.answers[i].options == null)
				{
					this.question.answers[i].options = new Object();
				}
				this.question.answers[i].options.feedback = _answerList[i].feedback;
				this.question.answers[i].options.letter = String.fromCharCode(_answerList[i].rowIndex + 65);
			}

			// update the question text
			if (this.question.questions.length == 0)
			{
				this.question.questions.push(new Object());
			}
			this.question.questions[0].text = questionField.text;

			_closeFunction.call(this);
			terminate();
		}
		public function onDeleteItem(event:DataEvent):void
		{
			var index:int = int(event.data);
			event.stopImmediatePropagation();
			this.question.answers[index];
			deleteItem(int(event.data));
		}
		public function onAddItem(event:Event):void
		{
			if (_answerList.length > MAX_ANSWERS)
			{
				Alert.show("You have reached the maximum number of answer choices allowed", "Too Many Answers");
				return;
			}
			event.stopImmediatePropagation();
			addAnswer();
		}
		private function onListItemFocusIn(event:ListEvent):void
		{
			MultipleChoiceItem(event.itemRenderer).setFocus();
		}
		private function onKeyDown(event:KeyboardEvent):void
		{
			if (event.keyCode == Keyboard.ESCAPE)
			{
				onDonePressed(true);
			}
		}
		private function onMouseDownOutside():void
		{
			onDonePressed(true);
		}
		]]>
	</mx:Script>
</mx:Canvas>
<mx:SWFLoader id="leftArrow" left="3" source="{new Enigma2PopupArrowLeft()}" />
<mx:SWFLoader id="rightArrow" right="1" source="{new Enigma2PopupArrowRight()}" />
</mx:Canvas>